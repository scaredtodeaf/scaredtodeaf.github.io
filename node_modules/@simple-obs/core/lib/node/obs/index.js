'use strict';

const _excluded = ["visible"],
      _excluded2 = ["scene", "name", "id", "position", "bounds", "crop", "scale"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const ObsWebSocket = require('obs-websocket-js');

const nextTick = require('next-tick');

const utils = require('../utils.js');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const ObsWebSocket__default = /*#__PURE__*/_interopDefault(ObsWebSocket);

const nextTick__default = /*#__PURE__*/_interopDefault(nextTick);

let requestCounter = 0;

function generateMessageId() {
  return (requestCounter++).toString();
}

class OBS {
  constructor() {
    _defineProperty(this, "socket", new ObsWebSocket__default.default());

    _defineProperty(this, "LOGGING", true);

    _defineProperty(this, "sources", new Map());

    _defineProperty(this, "scenes", new Map());

    _defineProperty(this, "useBatching", false);

    _defineProperty(this, "batchedSends", []);

    _defineProperty(this, "queued", false);
  }

  async connect(args) {
    await this.socket.connect(args);
    this.sources.clear();
    this.scenes.clear();
    this.socket.on("SceneItemTransformChanged", data => {
      this.socket.emit(`SceneItemTransformChanged:${data["scene-name"]}:${data["item-id"]}`, data.transform);
    });
  }

  clear() {
    this.sources.clear();
    this.scenes.clear();
  }

  disconnect() {
    this.socket.removeAllListeners();
    this.socket.disconnect();
    this.clear();
  }
  /**
   * Goes though each source in OBS and removes it if 1. simple-obs owns it and 2. there are no references
   * to the source in code.
   */


  async clean() {
    const _await$this$getSceneL = await this.getSceneList(),
          obsScenes = _await$this$getSceneL.scenes;

    const _await$this$getSource = await this.getSourcesList(),
          obsSources = _await$this$getSource.sources;

    const obsSourcesRefs = (await Promise.all(obsSources.map(source => this.getSourceSettings({
      name: source.name,
      type: source.typeId
    })).concat(obsScenes.map(source => this.getSourceSettings({
      name: source.name,
      type: "scene"
    }))))).reduce((acc, data) => _objectSpread(_objectSpread({}, acc), {}, {
      [data.sourceName]: data.sourceSettings.SIMPLE_OBS_LINKED ? undefined : data.sourceSettings.SIMPLE_OBS_REFS
    }), {}); // Delete refs that are actually in use

    for (let scene of this.scenes.values()) {
      for (let _ref of Object.entries(scene.items)) {
        var _obsSourcesRefs$item$, _obsSourcesRefs$item$2;

        var _ref2 = _slicedToArray(_ref, 2);

        let ref = _ref2[0];
        let item = _ref2[1];
        (_obsSourcesRefs$item$ = obsSourcesRefs[item.source.name]) === null || _obsSourcesRefs$item$ === void 0 ? true : (_obsSourcesRefs$item$2 = _obsSourcesRefs$item$[scene.name]) === null || _obsSourcesRefs$item$2 === void 0 ? true : delete _obsSourcesRefs$item$2[ref];
      }
    }

    let promises = []; // Delete scene items of sources that are not present in code

    for (let _ref3 of Object.entries(obsSourcesRefs).filter(([, v]) => v !== undefined)) {
      var _ref4 = _slicedToArray(_ref3, 2);

      let sourceName = _ref4[0];
      let sourceRefs = _ref4[1];

      for (let _ref5 of Object.entries(sourceRefs)) {
        var _ref6 = _slicedToArray(_ref5, 2);

        let scene = _ref6[0];
        let refs = _ref6[1];

        for (let id of Object.values(refs)) {
          if (obsSourcesRefs[scene] !== undefined) promises.push(obs.deleteSceneItem({
            scene,
            id,
            name: sourceName
          }));
        }
      }
    } // Filter out scenes for deletion that are not in use and we own


    const spareObsScenes = obsScenes.filter(scene => !this.scenes.has(scene.name) && obsSourcesRefs[scene.name] !== undefined);
    await Promise.all(promises);
    await utils.wait(50);
    await Promise.all(spareObsScenes.map(scene => this.removeScene(scene.name)));

    for (let codeScene of [...this.scenes.keys()]) {
      if (obsScenes.find(s => s.name === codeScene) === undefined) this.scenes.delete(codeScene);
    }

    for (let codeSource of [...this.sources.keys()]) {
      if (obsSources.find(s => s.name === codeSource) === undefined) this.sources.delete(codeSource);
    }

    await Promise.all([...[...this.sources.values()].map(async source => {
      await source.pushRefs();
      if (!source.linked) await source.refreshFilters();
    }), ...[...this.scenes.values()].map(scene => scene.pushRefs())]); // Let obs catch up - #21

    await utils.wait(100);
  }

  async sendBatch() {
    const data = await this.socket.send("ExecuteBatch", {
      requests: this.batchedSends
    });
    data.results.forEach(res => {
      this.socket.emit(`simple-obs:internal:message:id-${res["message-id"]}`, res.status === "error" ? res : undefined, res.status !== "error" ? res : undefined);
    });
    this.batchedSends = [];
    this.queued = false;
  }

  queueSendBatch() {
    if (this.queued) return;
    nextTick__default.default(() => this.sendBatch());
    this.queued = true;
  }

  batchSend(data) {
    this.batchedSends.push(data);
    this.queueSendBatch();
  }

  send(type, ...[args]) {
    if (this.useBatching) return new Promise((resolve, reject) => {
      const id = generateMessageId();
      this.socket.once(`simple-obs:internal:message:id-${id}`, (err, data) => {
        if (err) reject(_objectSpread(_objectSpread({}, err), {}, {
          type,
          args
        }));else resolve(data);
      });
      this.batchSend(_objectSpread(_objectSpread({}, args), {}, {
        "request-type": type,
        "message-id": id
      }));
    });else return this.socket.send(type, args);
  }

  on(type, listener) {
    // @ts-expect-error Overriding base types
    return this.socket.on(type, listener);
  }

  off(type, listener) {
    return this.socket.off(type, listener);
  }

  setSourceSettings(args) {
    return this.send("SetSourceSettings", {
      sourceName: args.name,
      sourceType: args.type,
      sourceSettings: args.settings
    });
  }

  createSource(args) {
    const _args$settings = args.settings,
          visible = _args$settings.visible,
          settings = _objectWithoutProperties(_args$settings, _excluded);

    return this.send("CreateSource", {
      sourceName: args.name,
      sourceKind: args.type,
      sceneName: args.scene,
      sourceSettings: settings,
      setVisible: visible
    });
  }

  createScene(name) {
    return this.send("CreateScene", {
      sceneName: name
    });
  }

  async removeScene(name) {
    const sceneList = (await this.getSceneList()).scenes; // TODO Potentially remove in the future with OBS-WS release

    await Promise.all(sceneList.reduce((acc, scene) => [...acc, ...scene.sources.map(sceneItem => sceneItem.name === name ? this.deleteSceneItem({
      scene: scene.name,
      name: name
    }) : Promise.resolve())], []));

    const _await$this$getSceneI = await this.getSceneItemList(name),
          sceneItems = _await$this$getSceneI.sceneItems;

    sceneItems.forEach(async sceneItem => {
      await this.deleteSceneItem({
        scene: name,
        id: sceneItem.itemId,
        name: sceneItem.sourceName
      });
    });
    await this.send("RemoveScene", {
      sceneName: name
    });
    return;
  }

  getSceneItemList(sceneName) {
    return this.send("GetSceneItemList", {
      sceneName
    });
  }

  addSceneItem(args) {
    return this.send("AddSceneItem", {
      sceneName: args.scene,
      sourceName: args.source,
      setVisible: args.visible
    });
  }

  setSceneItemProperties(_ref7) {
    let scene = _ref7.scene,
        name = _ref7.name,
        id = _ref7.id,
        position = _ref7.position,
        bounds = _ref7.bounds,
        crop = _ref7.crop,
        scale = _ref7.scale,
        properties = _objectWithoutProperties(_ref7, _excluded2);

    let item = id ? {
      id
    } : name;
    return this.send("SetSceneItemProperties", _objectSpread({
      "scene-name": scene,
      item,
      position: position !== null && position !== void 0 ? position : {},
      scale: scale !== null && scale !== void 0 ? scale : {},
      bounds: bounds !== null && bounds !== void 0 ? bounds : {},
      crop: crop !== null && crop !== void 0 ? crop : {}
    }, properties));
  }

  setCurrentScene(scene) {
    return this.send("SetCurrentScene", {
      "scene-name": scene
    });
  }

  getSceneItemProperties({
    id,
    name,
    scene
  }) {
    let item = id ? {
      id
    } : name;
    return this.send("GetSceneItemProperties", {
      "scene-name": scene,
      item
    });
  }

  getSourceSettings(args) {
    return this.send("GetSourceSettings", {
      sourceName: args.name,
      sourceType: args.type
    });
  }

  getSceneList() {
    return this.send("GetSceneList", {});
  }

  deleteSceneItem({
    scene,
    name,
    id
  }) {
    let item = id ? {
      id
    } : name;
    return this.send("DeleteSceneItem", {
      scene,
      item
    });
  }

  addFilterToSource({
    source,
    name,
    type,
    settings
  }) {
    return this.send("AddFilterToSource", {
      sourceName: source,
      filterName: name,
      filterType: type,
      filterSettings: settings
    });
  }

  setSourceFilterSettings({
    source,
    filter,
    settings
  }) {
    return this.send("SetSourceFilterSettings", {
      sourceName: source,
      filterName: filter,
      filterSettings: settings
    });
  }

  setSourceFilterVisibility({
    source,
    filter,
    visible
  }) {
    return this.send("SetSourceFilterVisibility", {
      sourceName: source,
      filterName: filter,
      filterEnabled: visible
    });
  }

  removeFilterFromSource({
    source,
    filter
  }) {
    return this.send("RemoveFilterFromSource", {
      sourceName: source,
      filterName: filter
    });
  }

  getSourceFilters({
    source
  }) {
    return this.send("GetSourceFilters", {
      sourceName: source
    });
  }

  reorderSourceFilter({
    source,
    filter,
    newIndex
  }) {
    return this.send("ReorderSourceFilter", {
      sourceName: source,
      filterName: filter,
      newIndex
    });
  }

  getSourceFilterInfo({
    source,
    filter
  }) {
    return this.send("GetSourceFilterInfo", {
      sourceName: source,
      filterName: filter
    });
  }

  reorderSceneItems({
    scene,
    items
  }) {
    return this.send("ReorderSceneItems", {
      scene,
      items: items.map(id => ({
        id
      }))
    });
  }

  getSourcesList() {
    return this.send("GetSourcesList", {});
  }

  getSourceTypesList() {
    return this.send("GetSourceTypesList", {});
  }

  getVideoInfo() {
    return this.send("GetVideoInfo", {});
  }

  log(...messages) {
    if (!obs.LOGGING) return;
    console.log(`OBS: `, ...messages);
  }

}

const obs = new OBS();
exports.obs = obs;
//# sourceMappingURL=index.js.map
