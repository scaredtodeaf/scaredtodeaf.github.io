'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const index = require('./obs/index.js');

const SceneItem = require('./SceneItem.js');

class Source {
  /**
   * Whether this source has at least one scene item in OBS
   */
  get exists() {
    return this._exists;
  }

  /**
   * Whether `initialize` has been called on this source yet
   */
  get initalized() {
    return this._initialized;
  }

  constructor(args) {
    var _args$settings, _args$filters;

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "_settingsType", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "settings", void 0);

    _defineProperty(this, "filters", {});

    _defineProperty(this, "linked", false);

    _defineProperty(this, "itemInstances", new Set());

    _defineProperty(this, "_exists", false);

    _defineProperty(this, "_initialized", false);

    _defineProperty(this, "refs", {});

    this.name = args.name;
    this.settings = (_args$settings = args.settings) !== null && _args$settings !== void 0 ? _args$settings : {};
    this.filters = (_args$filters = args.filters) !== null && _args$filters !== void 0 ? _args$filters : {};
  }
  /**
   * Sets this source's settings, both on this instance and the OBS source.
   *
   */


  async setSettings(settings) {
    await index.obs.setSourceSettings({
      name: this.name,
      type: this.type,
      settings
    });

    for (let setting in settings) {
      this.settings[setting] = settings[setting];
    }
  }
  /**
   * Adds a filter to this source, provided that 1. The filter has not already been applied
   * to another source, and 2. The source in OBS does not have a filter with a different type
   * but the same name as the filter being added. Does not support inserting at a particular order as of yet.
   */


  async addFilter(ref, filter) {
    if (filter.source) {
      throw new Error(`Filter ${this.name} has already been applied to source ${filter.source.name}`);
    }

    const exists = await index.obs.getSourceFilterInfo({
      source: this.name,
      filter: filter.name
    }).then(i => {
      if (i.type !== filter.type) throw new Error(`Filter ${this.name} already exists but has different type. Expected ${filter.type}, found ${i.type}`);
      return true;
    }).catch(() => false);
    filter.source = this;
    if (!exists) await index.obs.addFilterToSource(_objectSpread(_objectSpread({}, filter), {}, {
      source: this.name
    }));
    await filter.setSettings(filter.initialSettings);
    Object.assign(this.filters, {
      [ref]: filter
    });
  }
  /**
   * Overridable function for creating `SceneItem` instances for a source.
   * Doesn't create any objects in OBS. Instead, creates `SceneItem` instances that can
   * override default `SceneItem` behaviours.
   *
   * @returns An instance of `SceneItem` or a class that derives it.
   */


  createItemInstance(scene, id, ref) {
    return new SceneItem.SceneItem(this, scene, id, ref);
  }
  /**
   * Updates the source's filters in OBS so that they match the filters defined in `this.filters`.
   * This is done by removing filters that are present on the source in OBS but not on `this`, and adding filters that are present on `this` but not on the source.
   *
   * This shouldn't be required very often, probably only on source initialization.
   */


  async refreshFilters() {
    if (!this.exists) return;

    const _await$index$obs$getS = await index.obs.getSourceFilters({
      source: this.name
    }),
          sourceFilters = _await$index$obs$getS.filters;

    const filtersArray = Object.values(this.filters);
    const filtersToRemove = sourceFilters.filter(sourceFilter => // Only include filters where every local filter does not match
    filtersArray.every(filter => filter.name !== sourceFilter.name || filter.name === sourceFilter.name && filter.type !== sourceFilter.type));
    const filtersToAdd = filtersArray.filter(filter => // Only include filters where every sourceFilter is not found
    sourceFilters.every(sourceFilter => filter.name !== sourceFilter.name || filter.name === sourceFilter.name && filter.type !== sourceFilter.type));
    const filtersToUpdateSettings = filtersArray.filter(filter => sourceFilters.some(sourceFilter => filter.name === sourceFilter.name && filter.type === sourceFilter.type));
    await Promise.all([...filtersToRemove.map(f => index.obs.removeFilterFromSource({
      source: this.name,
      filter: f.name
    }), ...filtersToAdd.map(f => index.obs.addFilterToSource({
      source: this.name,
      name: f.name,
      settings: f.settings,
      type: f.type
    })), ...filtersToUpdateSettings.map(f => index.obs.setSourceFilterSettings({
      filter: f.name,
      source: this.name,
      settings: f.settings
    })))]);
    await Promise.all(filtersArray.map((filter, index$1) => index.obs.reorderSourceFilter({
      source: this.name,
      filter: filter.name,
      newIndex: index$1
    })));
  }
  /**
   * Fetches initial data for the source.
   *
   * @returns If the source has been initialized (will always be `true`).
   * Returns true immediately if already initialized, else will return a promise that resolves
   * when initialization is finished.
   *
   * Avoiding returning a promise where possible allows for tighter batching of obs requests that
   * happen in the same tick.
   *
   * @internal
   *
   */


  initialize() {
    if (this.initalized) return true;
    return index.obs.getSourceSettings({
      name: this.name
    }).then(async ({
      sourceSettings,
      sourceType
    }) => {
      // Exit if source exists but type doesn't match
      if (sourceType !== this.type) throw ["WRONG_TYPES", sourceType]; // Assign refs from previous runs of code

      if (sourceSettings.SIMPLE_OBS_REFS) this.refs = sourceSettings.SIMPLE_OBS_REFS;
      await this.saveRefs();
      index.obs.sources.set(this.name, this);
      this._exists = true;
      await this.initializeFilters();
      return this.exists;
    }).catch(e => {
      if (Array.isArray(e) && e[0] === "WRONG_TYPES") throw new Error(`Source with name ${this.name} has different type in OBS than expected. Found: ${e[1]}, Expected: ${this.type}`);
      return this._exists = false;
    }).finally(() => this._initialized = true);
  }
  /**
   * Creates a scene item of this source in the provided scene.
   * Requires that this source has been initialized.
   * If the source already exists, a new scene item will be created.
   * If not, the source will be created and added to the scene.
   *
   * @returns A SceneItem created by `Source.createSceneItem`
   * @internal
   */


  async createItem(ref, scene) {
    if (!this.initalized) throw new Error(`Cannot create item of source ${this.name} as it is not initialized`);
    let itemId;
    let properties = null;

    if (this.exists) {
      // First, attempt to connect to existing scene item with provided ref
      const id = this.getRef(scene.name, ref); // If a ref exists, get the properties of the referenced item

      if (id !== undefined) {
        try {
          properties = await index.obs.getSceneItemProperties({
            id,
            scene: scene.name
          });
          itemId = id;
        } catch {
          // If the item doesn't actually exist, remove the existing ref and create a new instance of the source
          this.removeRef(scene.name, ref);

          const _await$index$obs$addS = await index.obs.addSceneItem({
            scene: scene.name,
            source: this.name
          }),
                id = _await$index$obs$addS.itemId;

          itemId = id;
        }
      } else {
        // If no ref exists, we could try and look for items that match the source,
        // but that would defeat the point of `obs.clean`. Instead, we create a new item
        // of the source, keeping in mind that multiple items of a source can exist at once.
        // Thus, any old items of the source will exist alongisde the newly created item,
        // ready to be removed with `obs.clean`.
        // Also, not checking if a matching item already exists saves on OBS requests :)
        const _await$index$obs$addS2 = await index.obs.addSceneItem({
          scene: scene.name,
          source: this.name
        }),
              id = _await$index$obs$addS2.itemId;

        itemId = id;
      }
    } else {
      const _await$index$obs$crea = await index.obs.createSource({
        name: this.name,
        type: this.type,
        scene: scene.name,
        settings: this.settings
      }),
            newItemId = _await$index$obs$crea.itemId;

      index.obs.sources.set(this.name, this);
      this._exists = true;
      await this.initializeFilters();
      itemId = newItemId;
    } // As we have created a new scene item, set the corresponding ref.


    this.addRef(scene.name, ref, itemId); // Item for sure exists in OBS, so we create an instance to interact with it

    const item = this.createItemInstance(scene, itemId, ref); // If we found an existing item and got its properties, assign them

    if (properties !== null) item.properties = properties;
    return item;
  }
  /**
   * Uses the source's filterSchema to populate the filters property,
   * creating/linking with filters in OBS in the process.
   */


  async initializeFilters() {
    // Create a FilterInstance for each schema item. This allows for a filter schema to be
    // used multiple times, but exist in OBS as separate objects.
    for (let ref in this.filters) {
      let filter = this.filters[ref];
      filter.source = this; // Necessary since this is usually done in this.addFilter(), and this.refreshFilters() operates on filter.settings
      // Could probably just do addFilter in a loop instead of all this

      filter.settings = filter.initialSettings;
    } // We have the FilterInstances created, so we can just refresh as normal to create them in OBS


    await this.refreshFilters();
  }
  /**
   * Creates an instance of the source with the provided data and marks itself as existing and
   * initialized, as if the source was created by code.
   *
   * TODO: Matching settings and filters?
   *
   * @internal
   */


  linkItem(scene, id, ref) {
    this.linked = true;
    this._exists = true;
    this._initialized = true;
    return this.createItemInstance(scene, id, ref);
  }
  /**
   * REFS MANAGEMENT
   *
   * Methods and state for managing refs: Data stored in OBS that
   * links scene item references in code to scene item IDs in OBS,
   * so that scene items created in code can be recovered after code restarts,
   * removing the need for all scene items to be removed and recreated to guarantee
   * consistency between code and OBS.
   */

  /**
   * Source's refs.
   * Populated from OBS once on source creation but controlled by the source from then on.
   */


  /**
   * Sends this source's refs to OBS to be saved onto the source
   *
   * @throws If saving the refs fails
   */
  saveRefs() {
    // This isn't await-ed since the worst thing that can happen with a failed ref is a source is deleted by obs.clean.
    // We don't really care to know when it finishes.
    return index.obs.setSourceSettings({
      name: this.name,
      type: this.type,
      settings: {
        SIMPLE_OBS_REFS: this.refs
      }
    });
  }

  getRef(scene, ref) {
    if (this.refs[scene]) return this.refs[scene][ref];
    return undefined;
  }

  addRef(scene, ref, id) {
    var _this$refs;

    ((_this$refs = this.refs)[scene] || (_this$refs[scene] = {}))[ref] = id;
    this.saveRefs().catch(e => console.warn(`Failed to add ref ${ref} -> ${id}`, e));
  }

  removeRef(scene, ref) {
    if (!this.refs[scene]) return;
    delete this.refs[scene][ref];
    this.saveRefs().catch(e => console.warn(`Failed to remove ref ${ref}`, e));
  }
  /**
   * Gathers this source's itemRefs, calculates the refs value accordingly, and forcefully
   * pushes it to the source in OBS. This method is destructive, and should only be used sparingly.
   *
   * @internal
   */


  pushRefs() {
    let refs = {};
    this.itemInstances.forEach(item => {
      var _item$scene$name;

      (refs[_item$scene$name = item.scene.name] || (refs[_item$scene$name] = {}))[item.ref] = item.id;
    });
    this.refs = refs;
    return this.saveRefs();
  }

}

exports.Source = Source;
//# sourceMappingURL=Source.js.map
