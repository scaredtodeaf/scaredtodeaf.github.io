'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const index = require('./obs/index.js');

const utils = require('./utils.js');

exports.Alignment = void 0;

(function (Alignment) {
  Alignment[Alignment["CenterLeft"] = 1] = "CenterLeft";
  Alignment[Alignment["Center"] = 0] = "Center";
  Alignment[Alignment["CenterRight"] = 2] = "CenterRight";
  Alignment[Alignment["TopLeft"] = 5] = "TopLeft";
  Alignment[Alignment["TopCenter"] = 4] = "TopCenter";
  Alignment[Alignment["TopRight"] = 6] = "TopRight";
  Alignment[Alignment["BottomLeft"] = 9] = "BottomLeft";
  Alignment[Alignment["BottomCenter"] = 8] = "BottomCenter";
  Alignment[Alignment["BottomRight"] = 10] = "BottomRight";
})(exports.Alignment || (exports.Alignment = {}));

const DEFAULT_SCENE_ITEM_PROPERTIES = {
  position: {
    x: 0,
    y: 0,
    alignment: 0
  },
  scale: {
    x: 1,
    y: 1,
    filter: ""
  },
  crop: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  bounds: {
    type: "",
    alignment: 0,
    x: 0,
    y: 0
  },
  rotation: 0,
  visible: true,
  locked: false,
  sourceWidth: 0,
  sourceHeight: 0,
  width: 0,
  height: 0
};
/**
 * Represents an item of a source in OBS.
 * Creation of a SceneItem assumes that the item already exists in OBS.
 * It's the responsibility of the caller (probably a Source) to ensure that
 * the item has been created. SceneItems are for accessing already existing items.
 */

class SceneItem {
  constructor(source, scene, id, ref) {
    _defineProperty(this, "properties", {});

    this.source = source;
    this.scene = scene;
    this.id = id;
    this.ref = ref;
    source.itemInstances.add(this);
    utils.mergeDeep(this.properties, DEFAULT_SCENE_ITEM_PROPERTIES);
  }

  async setProperties(properties) {
    await index.obs.setSceneItemProperties(_objectSpread({
      scene: this.scene.name,
      id: this.id
    }, properties));
    utils.mergeDeep(this.properties, properties);
    this.updateSizeFromSource();
  }
  /**
   * Some sources have custom settings for width and height. Thus, sourceWidth and
   * sourceHeight for their scene items can change. This method reassigns these values and
   * calculates properties.width and properties.height as a product of the source dimensions
   * and item scale.
   */


  updateSizeFromSource(sourceWidth, sourceHeight) {
    this.properties.sourceWidth = sourceWidth !== null && sourceWidth !== void 0 ? sourceWidth : this.properties.sourceWidth;
    this.properties.sourceHeight = sourceHeight !== null && sourceHeight !== void 0 ? sourceHeight : this.properties.sourceHeight;
    this.properties.width = this.properties.scale.x * this.properties.sourceWidth;
    this.properties.height = this.properties.scale.y * this.properties.sourceHeight;
  }

  async getProperties() {
    const newProperties = await index.obs.getSceneItemProperties({
      id: this.id,
      scene: this.scene.name
    });
    utils.mergeDeep(this.properties, newProperties);
    return this.properties;
  }

  delete() {
    this.source.itemInstances.delete(this);
    return index.obs.deleteSceneItem({
      scene: this.scene.name,
      id: this.id
    });
  }

}

exports.DEFAULT_SCENE_ITEM_PROPERTIES = DEFAULT_SCENE_ITEM_PROPERTIES;
exports.SceneItem = SceneItem;
//# sourceMappingURL=SceneItem.js.map
