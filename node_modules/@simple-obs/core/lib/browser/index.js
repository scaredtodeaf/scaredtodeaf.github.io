// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: lib
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const ObsWebSocket = require('obs-websocket-js');

const nextTick = require('next-tick');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const ObsWebSocket__default = /*#__PURE__*/_interopDefault(ObsWebSocket);

const nextTick__default = /*#__PURE__*/_interopDefault(nextTick);

function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}

function mergeDeep(target, data, ignoreMissing = true) {
  if (isObject(target) && isObject(data)) {
    for (const key in data) {
      if (isObject(data[key])) {
        if (!target[key]) Object.assign(target, {
          [key]: {}
        });
        mergeDeep(target[key], data[key], ignoreMissing);
      } else {
        if (!ignoreMissing || data[key] !== undefined) Object.assign(target, {
          [key]: data[key]
        });
      }
    }
  }

  return target;
}

const wait = ms => new Promise(r => setTimeout(r, ms));

let requestCounter = 0;

function generateMessageId() {
  return (requestCounter++).toString();
}

class OBS {
  constructor() {
    _defineProperty(this, "socket", new ObsWebSocket__default.default());

    _defineProperty(this, "LOGGING", true);

    _defineProperty(this, "sources", new Map());

    _defineProperty(this, "scenes", new Map());

    _defineProperty(this, "useBatching", false);

    _defineProperty(this, "batchedSends", []);

    _defineProperty(this, "queued", false);
  }

  async connect(args) {
    await this.socket.connect(args);
    this.sources.clear();
    this.scenes.clear();
    this.socket.on("SceneItemTransformChanged", data => {
      this.socket.emit(`SceneItemTransformChanged:${data["scene-name"]}:${data["item-id"]}`, data.transform);
    });
  }

  clear() {
    this.sources.clear();
    this.scenes.clear();
  }

  disconnect() {
    this.socket.removeAllListeners();
    this.socket.disconnect();
    this.clear();
  }
  /**
   * Goes though each source in OBS and removes it if 1. simple-obs owns it and 2. there are no references
   * to the source in code.
   */


  async clean() {
    const {
      scenes: obsScenes
    } = await this.getSceneList();
    const {
      sources: obsSources
    } = await this.getSourcesList();
    const obsSourcesRefs = (await Promise.all(obsSources.map(source => this.getSourceSettings({
      name: source.name,
      type: source.typeId
    })).concat(obsScenes.map(source => this.getSourceSettings({
      name: source.name,
      type: "scene"
    }))))).reduce((acc, data) => ({ ...acc,
      [data.sourceName]: data.sourceSettings.SIMPLE_OBS_LINKED ? undefined : data.sourceSettings.SIMPLE_OBS_REFS
    }), {}); // Delete refs that are actually in use

    for (let scene of this.scenes.values()) {
      for (let [ref, item] of Object.entries(scene.items)) {
        var _obsSourcesRefs$item$, _obsSourcesRefs$item$2;

        (_obsSourcesRefs$item$ = obsSourcesRefs[item.source.name]) === null || _obsSourcesRefs$item$ === void 0 ? true : (_obsSourcesRefs$item$2 = _obsSourcesRefs$item$[scene.name]) === null || _obsSourcesRefs$item$2 === void 0 ? true : delete _obsSourcesRefs$item$2[ref];
      }
    }

    let promises = []; // Delete scene items of sources that are not present in code

    for (let [sourceName, sourceRefs] of Object.entries(obsSourcesRefs).filter(([, v]) => v !== undefined)) {
      for (let [scene, refs] of Object.entries(sourceRefs)) {
        for (let id of Object.values(refs)) {
          if (obsSourcesRefs[scene] !== undefined) promises.push(obs.deleteSceneItem({
            scene,
            id,
            name: sourceName
          }));
        }
      }
    } // Filter out scenes for deletion that are not in use and we own


    const spareObsScenes = obsScenes.filter(scene => !this.scenes.has(scene.name) && obsSourcesRefs[scene.name] !== undefined);
    await Promise.all(promises);
    await wait(50);
    await Promise.all(spareObsScenes.map(scene => this.removeScene(scene.name)));

    for (let codeScene of [...this.scenes.keys()]) {
      if (obsScenes.find(s => s.name === codeScene) === undefined) this.scenes.delete(codeScene);
    }

    for (let codeSource of [...this.sources.keys()]) {
      if (obsSources.find(s => s.name === codeSource) === undefined) this.sources.delete(codeSource);
    }

    await Promise.all([...[...this.sources.values()].map(async source => {
      await source.pushRefs();
      if (!source.linked) await source.refreshFilters();
    }), ...[...this.scenes.values()].map(scene => scene.pushRefs())]); // Let obs catch up - #21

    await wait(100);
  }

  async sendBatch() {
    const data = await this.socket.send("ExecuteBatch", {
      requests: this.batchedSends
    });
    data.results.forEach(res => {
      this.socket.emit(`simple-obs:internal:message:id-${res["message-id"]}`, res.status === "error" ? res : undefined, res.status !== "error" ? res : undefined);
    });
    this.batchedSends = [];
    this.queued = false;
  }

  queueSendBatch() {
    if (this.queued) return;
    nextTick__default.default(() => this.sendBatch());
    this.queued = true;
  }

  batchSend(data) {
    this.batchedSends.push(data);
    this.queueSendBatch();
  }

  send(type, ...[args]) {
    if (this.useBatching) return new Promise((resolve, reject) => {
      const id = generateMessageId();
      this.socket.once(`simple-obs:internal:message:id-${id}`, (err, data) => {
        if (err) reject({ ...err,
          type,
          args
        });else resolve(data);
      });
      this.batchSend({ ...args,
        "request-type": type,
        "message-id": id
      });
    });else return this.socket.send(type, args);
  }

  on(type, listener) {
    // @ts-expect-error Overriding base types
    return this.socket.on(type, listener);
  }

  off(type, listener) {
    return this.socket.off(type, listener);
  }

  setSourceSettings(args) {
    return this.send("SetSourceSettings", {
      sourceName: args.name,
      sourceType: args.type,
      sourceSettings: args.settings
    });
  }

  createSource(args) {
    const {
      visible,
      ...settings
    } = args.settings;
    return this.send("CreateSource", {
      sourceName: args.name,
      sourceKind: args.type,
      sceneName: args.scene,
      sourceSettings: settings,
      setVisible: visible
    });
  }

  createScene(name) {
    return this.send("CreateScene", {
      sceneName: name
    });
  }

  async removeScene(name) {
    const sceneList = (await this.getSceneList()).scenes; // TODO Potentially remove in the future with OBS-WS release

    await Promise.all(sceneList.reduce((acc, scene) => [...acc, ...scene.sources.map(sceneItem => sceneItem.name === name ? this.deleteSceneItem({
      scene: scene.name,
      name: name
    }) : Promise.resolve())], []));
    const {
      sceneItems
    } = await this.getSceneItemList(name);
    sceneItems.forEach(async sceneItem => {
      await this.deleteSceneItem({
        scene: name,
        id: sceneItem.itemId,
        name: sceneItem.sourceName
      });
    });
    await this.send("RemoveScene", {
      sceneName: name
    });
    return;
  }

  getSceneItemList(sceneName) {
    return this.send("GetSceneItemList", {
      sceneName
    });
  }

  addSceneItem(args) {
    return this.send("AddSceneItem", {
      sceneName: args.scene,
      sourceName: args.source,
      setVisible: args.visible
    });
  }

  setSceneItemProperties({
    scene,
    name,
    id,
    position,
    bounds,
    crop,
    scale,
    ...properties
  }) {
    let item = id ? {
      id
    } : name;
    return this.send("SetSceneItemProperties", {
      "scene-name": scene,
      item,
      position: position !== null && position !== void 0 ? position : {},
      scale: scale !== null && scale !== void 0 ? scale : {},
      bounds: bounds !== null && bounds !== void 0 ? bounds : {},
      crop: crop !== null && crop !== void 0 ? crop : {},
      ...properties
    });
  }

  setCurrentScene(scene) {
    return this.send("SetCurrentScene", {
      "scene-name": scene
    });
  }

  getSceneItemProperties({
    id,
    name,
    scene
  }) {
    let item = id ? {
      id
    } : name;
    return this.send("GetSceneItemProperties", {
      "scene-name": scene,
      item
    });
  }

  getSourceSettings(args) {
    return this.send("GetSourceSettings", {
      sourceName: args.name,
      sourceType: args.type
    });
  }

  getSceneList() {
    return this.send("GetSceneList", {});
  }

  deleteSceneItem({
    scene,
    name,
    id
  }) {
    let item = id ? {
      id
    } : name;
    return this.send("DeleteSceneItem", {
      scene,
      item
    });
  }

  addFilterToSource({
    source,
    name,
    type,
    settings
  }) {
    return this.send("AddFilterToSource", {
      sourceName: source,
      filterName: name,
      filterType: type,
      filterSettings: settings
    });
  }

  setSourceFilterSettings({
    source,
    filter,
    settings
  }) {
    return this.send("SetSourceFilterSettings", {
      sourceName: source,
      filterName: filter,
      filterSettings: settings
    });
  }

  setSourceFilterVisibility({
    source,
    filter,
    visible
  }) {
    return this.send("SetSourceFilterVisibility", {
      sourceName: source,
      filterName: filter,
      filterEnabled: visible
    });
  }

  removeFilterFromSource({
    source,
    filter
  }) {
    return this.send("RemoveFilterFromSource", {
      sourceName: source,
      filterName: filter
    });
  }

  getSourceFilters({
    source
  }) {
    return this.send("GetSourceFilters", {
      sourceName: source
    });
  }

  reorderSourceFilter({
    source,
    filter,
    newIndex
  }) {
    return this.send("ReorderSourceFilter", {
      sourceName: source,
      filterName: filter,
      newIndex
    });
  }

  getSourceFilterInfo({
    source,
    filter
  }) {
    return this.send("GetSourceFilterInfo", {
      sourceName: source,
      filterName: filter
    });
  }

  reorderSceneItems({
    scene,
    items
  }) {
    return this.send("ReorderSceneItems", {
      scene,
      items: items.map(id => ({
        id
      }))
    });
  }

  getSourcesList() {
    return this.send("GetSourcesList", {});
  }

  getSourceTypesList() {
    return this.send("GetSourceTypesList", {});
  }

  getVideoInfo() {
    return this.send("GetVideoInfo", {});
  }

  log(...messages) {
    if (!obs.LOGGING) return;
    console.log(`OBS: `, ...messages);
  }

}

const obs = new OBS();
exports.Alignment = void 0;

(function (Alignment) {
  Alignment[Alignment["CenterLeft"] = 1] = "CenterLeft";
  Alignment[Alignment["Center"] = 0] = "Center";
  Alignment[Alignment["CenterRight"] = 2] = "CenterRight";
  Alignment[Alignment["TopLeft"] = 5] = "TopLeft";
  Alignment[Alignment["TopCenter"] = 4] = "TopCenter";
  Alignment[Alignment["TopRight"] = 6] = "TopRight";
  Alignment[Alignment["BottomLeft"] = 9] = "BottomLeft";
  Alignment[Alignment["BottomCenter"] = 8] = "BottomCenter";
  Alignment[Alignment["BottomRight"] = 10] = "BottomRight";
})(exports.Alignment || (exports.Alignment = {}));

const DEFAULT_SCENE_ITEM_PROPERTIES = {
  position: {
    x: 0,
    y: 0,
    alignment: 0
  },
  scale: {
    x: 1,
    y: 1,
    filter: ""
  },
  crop: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  bounds: {
    type: "",
    alignment: 0,
    x: 0,
    y: 0
  },
  rotation: 0,
  visible: true,
  locked: false,
  sourceWidth: 0,
  sourceHeight: 0,
  width: 0,
  height: 0
};
/**
 * Represents an item of a source in OBS.
 * Creation of a SceneItem assumes that the item already exists in OBS.
 * It's the responsibility of the caller (probably a Source) to ensure that
 * the item has been created. SceneItems are for accessing already existing items.
 */

class SceneItem {
  constructor(source, scene, id, ref) {
    _defineProperty(this, "properties", {});

    this.source = source;
    this.scene = scene;
    this.id = id;
    this.ref = ref;
    source.itemInstances.add(this);
    mergeDeep(this.properties, DEFAULT_SCENE_ITEM_PROPERTIES);
  }

  async setProperties(properties) {
    await obs.setSceneItemProperties({
      scene: this.scene.name,
      id: this.id,
      ...properties
    });
    mergeDeep(this.properties, properties);
    this.updateSizeFromSource();
  }
  /**
   * Some sources have custom settings for width and height. Thus, sourceWidth and
   * sourceHeight for their scene items can change. This method reassigns these values and
   * calculates properties.width and properties.height as a product of the source dimensions
   * and item scale.
   */


  updateSizeFromSource(sourceWidth, sourceHeight) {
    this.properties.sourceWidth = sourceWidth !== null && sourceWidth !== void 0 ? sourceWidth : this.properties.sourceWidth;
    this.properties.sourceHeight = sourceHeight !== null && sourceHeight !== void 0 ? sourceHeight : this.properties.sourceHeight;
    this.properties.width = this.properties.scale.x * this.properties.sourceWidth;
    this.properties.height = this.properties.scale.y * this.properties.sourceHeight;
  }

  async getProperties() {
    const newProperties = await obs.getSceneItemProperties({
      id: this.id,
      scene: this.scene.name
    });
    mergeDeep(this.properties, newProperties);
    return this.properties;
  }

  delete() {
    this.source.itemInstances.delete(this);
    return obs.deleteSceneItem({
      scene: this.scene.name,
      id: this.id
    });
  }

}

class Source {
  /**
   * Whether this source has at least one scene item in OBS
   */
  get exists() {
    return this._exists;
  }

  /**
   * Whether `initialize` has been called on this source yet
   */
  get initalized() {
    return this._initialized;
  }

  constructor(args) {
    var _args$settings, _args$filters;

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "_settingsType", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "settings", void 0);

    _defineProperty(this, "filters", {});

    _defineProperty(this, "linked", false);

    _defineProperty(this, "itemInstances", new Set());

    _defineProperty(this, "_exists", false);

    _defineProperty(this, "_initialized", false);

    _defineProperty(this, "refs", {});

    this.name = args.name;
    this.settings = (_args$settings = args.settings) !== null && _args$settings !== void 0 ? _args$settings : {};
    this.filters = (_args$filters = args.filters) !== null && _args$filters !== void 0 ? _args$filters : {};
  }
  /**
   * Sets this source's settings, both on this instance and the OBS source.
   *
   */


  async setSettings(settings) {
    await obs.setSourceSettings({
      name: this.name,
      type: this.type,
      settings
    });

    for (let setting in settings) {
      this.settings[setting] = settings[setting];
    }
  }
  /**
   * Adds a filter to this source, provided that 1. The filter has not already been applied
   * to another source, and 2. The source in OBS does not have a filter with a different type
   * but the same name as the filter being added. Does not support inserting at a particular order as of yet.
   */


  async addFilter(ref, filter) {
    if (filter.source) {
      throw new Error(`Filter ${this.name} has already been applied to source ${filter.source.name}`);
    }

    const exists = await obs.getSourceFilterInfo({
      source: this.name,
      filter: filter.name
    }).then(i => {
      if (i.type !== filter.type) throw new Error(`Filter ${this.name} already exists but has different type. Expected ${filter.type}, found ${i.type}`);
      return true;
    }).catch(() => false);
    filter.source = this;
    if (!exists) await obs.addFilterToSource({ ...filter,
      source: this.name
    });
    await filter.setSettings(filter.initialSettings);
    Object.assign(this.filters, {
      [ref]: filter
    });
  }
  /**
   * Overridable function for creating `SceneItem` instances for a source.
   * Doesn't create any objects in OBS. Instead, creates `SceneItem` instances that can
   * override default `SceneItem` behaviours.
   *
   * @returns An instance of `SceneItem` or a class that derives it.
   */


  createItemInstance(scene, id, ref) {
    return new SceneItem(this, scene, id, ref);
  }
  /**
   * Updates the source's filters in OBS so that they match the filters defined in `this.filters`.
   * This is done by removing filters that are present on the source in OBS but not on `this`, and adding filters that are present on `this` but not on the source.
   *
   * This shouldn't be required very often, probably only on source initialization.
   */


  async refreshFilters() {
    if (!this.exists) return;
    const {
      filters: sourceFilters
    } = await obs.getSourceFilters({
      source: this.name
    });
    const filtersArray = Object.values(this.filters);
    const filtersToRemove = sourceFilters.filter(sourceFilter => // Only include filters where every local filter does not match
    filtersArray.every(filter => filter.name !== sourceFilter.name || filter.name === sourceFilter.name && filter.type !== sourceFilter.type));
    const filtersToAdd = filtersArray.filter(filter => // Only include filters where every sourceFilter is not found
    sourceFilters.every(sourceFilter => filter.name !== sourceFilter.name || filter.name === sourceFilter.name && filter.type !== sourceFilter.type));
    const filtersToUpdateSettings = filtersArray.filter(filter => sourceFilters.some(sourceFilter => filter.name === sourceFilter.name && filter.type === sourceFilter.type));
    await Promise.all([...filtersToRemove.map(f => obs.removeFilterFromSource({
      source: this.name,
      filter: f.name
    }), ...filtersToAdd.map(f => obs.addFilterToSource({
      source: this.name,
      name: f.name,
      settings: f.settings,
      type: f.type
    })), ...filtersToUpdateSettings.map(f => obs.setSourceFilterSettings({
      filter: f.name,
      source: this.name,
      settings: f.settings
    })))]);
    await Promise.all(filtersArray.map((filter, index) => obs.reorderSourceFilter({
      source: this.name,
      filter: filter.name,
      newIndex: index
    })));
  }
  /**
   * Fetches initial data for the source.
   *
   * @returns If the source has been initialized (will always be `true`).
   * Returns true immediately if already initialized, else will return a promise that resolves
   * when initialization is finished.
   *
   * Avoiding returning a promise where possible allows for tighter batching of obs requests that
   * happen in the same tick.
   *
   * @internal
   *
   */


  initialize() {
    if (this.initalized) return true;
    return obs.getSourceSettings({
      name: this.name
    }).then(async ({
      sourceSettings,
      sourceType
    }) => {
      // Exit if source exists but type doesn't match
      if (sourceType !== this.type) throw ["WRONG_TYPES", sourceType]; // Assign refs from previous runs of code

      if (sourceSettings.SIMPLE_OBS_REFS) this.refs = sourceSettings.SIMPLE_OBS_REFS;
      await this.saveRefs();
      obs.sources.set(this.name, this);
      this._exists = true;
      await this.initializeFilters();
      return this.exists;
    }).catch(e => {
      if (Array.isArray(e) && e[0] === "WRONG_TYPES") throw new Error(`Source with name ${this.name} has different type in OBS than expected. Found: ${e[1]}, Expected: ${this.type}`);
      return this._exists = false;
    }).finally(() => this._initialized = true);
  }
  /**
   * Creates a scene item of this source in the provided scene.
   * Requires that this source has been initialized.
   * If the source already exists, a new scene item will be created.
   * If not, the source will be created and added to the scene.
   *
   * @returns A SceneItem created by `Source.createSceneItem`
   * @internal
   */


  async createItem(ref, scene) {
    if (!this.initalized) throw new Error(`Cannot create item of source ${this.name} as it is not initialized`);
    let itemId;
    let properties = null;

    if (this.exists) {
      // First, attempt to connect to existing scene item with provided ref
      const id = this.getRef(scene.name, ref); // If a ref exists, get the properties of the referenced item

      if (id !== undefined) {
        try {
          properties = await obs.getSceneItemProperties({
            id,
            scene: scene.name
          });
          itemId = id;
        } catch {
          // If the item doesn't actually exist, remove the existing ref and create a new instance of the source
          this.removeRef(scene.name, ref);
          const {
            itemId: id
          } = await obs.addSceneItem({
            scene: scene.name,
            source: this.name
          });
          itemId = id;
        }
      } else {
        // If no ref exists, we could try and look for items that match the source,
        // but that would defeat the point of `obs.clean`. Instead, we create a new item
        // of the source, keeping in mind that multiple items of a source can exist at once.
        // Thus, any old items of the source will exist alongisde the newly created item,
        // ready to be removed with `obs.clean`.
        // Also, not checking if a matching item already exists saves on OBS requests :)
        const {
          itemId: id
        } = await obs.addSceneItem({
          scene: scene.name,
          source: this.name
        });
        itemId = id;
      }
    } else {
      const {
        itemId: newItemId
      } = await obs.createSource({
        name: this.name,
        type: this.type,
        scene: scene.name,
        settings: this.settings
      });
      obs.sources.set(this.name, this);
      this._exists = true;
      await this.initializeFilters();
      itemId = newItemId;
    } // As we have created a new scene item, set the corresponding ref.


    this.addRef(scene.name, ref, itemId); // Item for sure exists in OBS, so we create an instance to interact with it

    const item = this.createItemInstance(scene, itemId, ref); // If we found an existing item and got its properties, assign them

    if (properties !== null) item.properties = properties;
    return item;
  }
  /**
   * Uses the source's filterSchema to populate the filters property,
   * creating/linking with filters in OBS in the process.
   */


  async initializeFilters() {
    // Create a FilterInstance for each schema item. This allows for a filter schema to be
    // used multiple times, but exist in OBS as separate objects.
    for (let ref in this.filters) {
      let filter = this.filters[ref];
      filter.source = this; // Necessary since this is usually done in this.addFilter(), and this.refreshFilters() operates on filter.settings
      // Could probably just do addFilter in a loop instead of all this

      filter.settings = filter.initialSettings;
    } // We have the FilterInstances created, so we can just refresh as normal to create them in OBS


    await this.refreshFilters();
  }
  /**
   * Creates an instance of the source with the provided data and marks itself as existing and
   * initialized, as if the source was created by code.
   *
   * TODO: Matching settings and filters?
   *
   * @internal
   */


  linkItem(scene, id, ref) {
    this.linked = true;
    this._exists = true;
    this._initialized = true;
    return this.createItemInstance(scene, id, ref);
  }
  /**
   * REFS MANAGEMENT
   *
   * Methods and state for managing refs: Data stored in OBS that
   * links scene item references in code to scene item IDs in OBS,
   * so that scene items created in code can be recovered after code restarts,
   * removing the need for all scene items to be removed and recreated to guarantee
   * consistency between code and OBS.
   */

  /**
   * Source's refs.
   * Populated from OBS once on source creation but controlled by the source from then on.
   */


  /**
   * Sends this source's refs to OBS to be saved onto the source
   *
   * @throws If saving the refs fails
   */
  saveRefs() {
    // This isn't await-ed since the worst thing that can happen with a failed ref is a source is deleted by obs.clean.
    // We don't really care to know when it finishes.
    return obs.setSourceSettings({
      name: this.name,
      type: this.type,
      settings: {
        SIMPLE_OBS_REFS: this.refs
      }
    });
  }

  getRef(scene, ref) {
    if (this.refs[scene]) return this.refs[scene][ref];
    return undefined;
  }

  addRef(scene, ref, id) {
    var _this$refs;

    ((_this$refs = this.refs)[scene] || (_this$refs[scene] = {}))[ref] = id;
    this.saveRefs().catch(e => console.warn(`Failed to add ref ${ref} -> ${id}`, e));
  }

  removeRef(scene, ref) {
    if (!this.refs[scene]) return;
    delete this.refs[scene][ref];
    this.saveRefs().catch(e => console.warn(`Failed to remove ref ${ref}`, e));
  }
  /**
   * Gathers this source's itemRefs, calculates the refs value accordingly, and forcefully
   * pushes it to the source in OBS. This method is destructive, and should only be used sparingly.
   *
   * @internal
   */


  pushRefs() {
    let refs = {};
    this.itemInstances.forEach(item => {
      var _item$scene$name;

      (refs[_item$scene$name = item.scene.name] || (refs[_item$scene$name] = {}))[item.ref] = item.id;
    });
    this.refs = refs;
    return this.saveRefs();
  }

}

class Scene extends Source {
  // Default initialized to {} as items is populated later by initialize addItem

  /**
   * PUBLIC METHODS
   *
   * Methods that can be called by code that uses obs-js
   */

  /**  */
  constructor(args) {
    super(args);

    _defineProperty(this, "type", "scene");

    _defineProperty(this, "items", {});

    _defineProperty(this, "itemsSchema", void 0);

    this.itemsSchema = args.items;
  }
  /**
   * Creates a scene in OBS and populates it with items as defined by the scene's items schema.
   *
   * Can be called normally, and is also called by `Scene.addItem` through the `Scene.createItem` override.
   */


  async create() {
    // If scene exists, it is initialized. Thus, no need to throw an error if it's already initialized
    if (this.exists) return this;
    await super.initialize();

    if (!this.exists) {
      await obs.createScene(this.name);
      await this.saveRefs();
    }

    await wait(50);
    this._exists = true;
    obs.scenes.set(this.name, this);

    for (const ref in this.itemsSchema) {
      await this.addItem(ref, this.itemsSchema[ref]);
    }

    const itemList = await obs.getSceneItemList(this.name);
    let ownedItemIds = Object.keys(this.itemsSchema).reverse().map(ref => this.items[ref].id);
    const allItemsOrdered = [...itemList.sceneItems.filter(({
      itemId
    }) => !ownedItemIds.includes(itemId)).map(({
      itemId
    }) => itemId).reverse(), ...ownedItemIds];
    if (allItemsOrdered.length > 0) await obs.reorderSceneItems({
      scene: this.name,
      items: allItemsOrdered
    });
    await this.setSettings({
      SIMPLE_OBS_LINKED: false
    });
    return this;
  }
  /**
   * Links to an existing scene in OBS, verifying that all sources as defined by the scene's items schema exist.
   * Will mark itself as existing if a matching scene is found, but will still throw if the items schema is not matched.
   */


  async link(options) {
    if (this.initalized) throw new Error(`Cannot link scene ${this.name} that has already been initialized`); // First, check if the scene exists by fetching its scene item list. Fail if scene isn't found

    const {
      sceneItems
    } = await obs.getSceneItemList(this.name);
    this._exists = true;
    let multipleItemSources = [],
        noItemSources = []; // Iterate through the required items a first time to determine if the scene can be linked

    for (let ref in this.itemsSchema) {
      let itemSchema = this.itemsSchema[ref]; // Get all items in scene with current item's source type

      const sourceItems = sceneItems.filter(i => i.sourceName === itemSchema.source.name);
      if (sourceItems.length === 0) multipleItemSources.push(itemSchema.source);else if (sourceItems.length > 1) noItemSources.push(itemSchema.source);else continue;
    } // If multiple or none of any of the sources exist as items in the scene, fail


    if (multipleItemSources.length !== 0 || noItemSources.length !== 0) throw new Error(`Failed to link scene ${this.name}:${multipleItemSources.length !== 0 ? ` Scene contians multiple items of source${multipleItemSources.length > 1 ? "s" : ""} ${multipleItemSources.map(s => `'${s.name}'`).join(", ")}.` : ``}${noItemSources.length !== 0 ? ` Scene contians no items of source${noItemSources.length > 1 ? "s" : ""} ${noItemSources.map(s => `'${s.name}'`).join(", ")}.` : ``}`); // Iterate through a second time to actually link the scene items.

    await Promise.all(Object.entries(this.itemsSchema).map(async ([ref, {
      source,
      ...properties
    }]) => {
      const schemaItem = sceneItems.find(i => i.sourceName === source.name); // Create a SceneItem for the source, marking the source as inialized and such in the process

      const item = source.linkItem(this, schemaItem.itemId, ref);
      Object.assign(this.items, {
        [ref]: item
      });
      await item.getProperties();
      let optionRequests = [];
      if (options !== null && options !== void 0 && options.setProperties) optionRequests.push(item.setProperties(properties));
      if (options !== null && options !== void 0 && options.setSourceSettings) optionRequests.push(source.setSettings(source.settings));
      return Promise.all(optionRequests);
    }));
    await this.setSettings({
      SIMPLE_OBS_LINKED: true
    }); // TODO: Ordering options
  }

  async addItem(ref, {
    source,
    ...properties
  }) {
    // We only need to update the source after the first time the source is initialized
    const sourceNeedsUpdating = !source.initalized; // First, check if the source is initialized to ensure that `source.exists` is accurate

    let initialized = source.initialize();
    if (initialized !== true) await initialized;
    let item; // Source is initialized, try to create an item of it, letting the source be
    // responsible for creating itself if required

    item = await source.createItem(ref, this);
    const sourceUpdateRequests = sourceNeedsUpdating ? [source.setSettings(source.settings) // source.refreshFilters()
    ] : []; // We always need to set the item properties, but only need to set source settings and the like once
    // when we initalize the source

    await Promise.all([item.setProperties(properties), ...sourceUpdateRequests]); // Get the item's properties and assign them in case some properties are dependent
    // on things like source settings (eg. Image source, where width and height is dependent
    // on the size of the image)

    const data = await item.getProperties();
    mergeDeep(item.properties, data);
    Object.assign(this.items, {
      [ref]: item
    });
    return item;
  }
  /**
   * Just wraps `obs.createScene` and sets `this._exists`
   */


  async _create() {}
  /**
   * UTILITIES
   *
   * Utility functions that wrap basic OBS functions.
   */

  /** */


  makeCurrentScene() {
    return obs.setCurrentScene(this.name);
  }

  async remove() {
    await obs.removeScene(this.name);
    obs.scenes.delete(this.name);
    obs.sources.delete(this.name);
    this._exists = false;
  }
  /**
   * CREATE ITEM OVERRIDES
   *
   * These are necessary since Scenes are different from regular Sources in how they
   * generate. They don't have a concept of an initial item as they can exist with 0 items.
   * Thus as long as the scene is initialized, `createInitialItem` can just call regular `createItem`
   */

  /**
   * @internal
   * @override
   */


  async createItem(ref, scene) {
    if (!this.exists) await this.create();
    return await super.createItem(ref, scene);
  }
  /**
   * @internal
   * @override
   */


  createInitialItem(ref, scene) {
    return this.createItem(ref, scene);
  }

}

class Filter {
  /**
   * @internal
   */
  constructor({
    name,
    settings
  }) {
    _defineProperty(this, "initialSettings", void 0);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "source", void 0);

    _defineProperty(this, "settings", {});

    _defineProperty(this, "visible", true);

    _defineProperty(this, "_settingsType", void 0);

    this.name = name;
    this.initialSettings = settings;
  }

  async setSettings(settings) {
    if (!this.source) {
      console.warn(`Attempted to set settings on sourceless filter ${this.name}`);
      return;
    }

    await obs.setSourceFilterSettings({
      source: this.source.name,
      filter: this.name,
      settings: settings
    });

    for (let setting in settings) {
      this.settings[setting] = settings[setting];
    }
  }

  setVisible(visible) {
    if (!this.source) {
      console.warn(`Attempted to set visibility on sourceless filter ${this.name}`);
      return;
    }

    this.visible = visible;
    return obs.setSourceFilterVisibility({
      source: this.source.name,
      filter: this.name,
      visible
    });
  }

}

class ImageSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "image_source");
  }

}

class BrowserSourceItem extends SceneItem {
  constructor(source, scene, id, ref) {
    super(source, scene, id, ref);
    this.updateSizeFromSource(source.settings.width, source.settings.height);
  }

}
/**
 * **Warning**: BrowserSource items will not have correct properties when they are
 * initialized, as browser sources are always created with a width and height of 0.
 * If width and height are not provided in the source's intial settings, it's intial
 * item will have a width and height of 0 until item.getProperties is called,
 * or the source's width and height are updated.
 */


class BrowserSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "browser_source");
  }

  createItemInstance(scene, id, ref) {
    return new BrowserSourceItem(this, scene, id, ref);
  }

  async setSettings(settings) {
    await super.setSettings(settings);
    this.itemInstances.forEach(item => item.updateSizeFromSource(this.settings.width, this.settings.height));
  }

}

class ColorSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "color_source_v3");
  }

  async setSettings(settings) {
    await super.setSettings(settings);
    this.itemInstances.forEach(item => item.updateSizeFromSource(this.settings.width, this.settings.height));
  }

}

class FreetypeTextSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "text_ft2_source_v2");
  }

}

class GDIPlusTextSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "text_gdiplus_v2");
  }

}

class MediaSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "ffmpeg_source");
  }

}

class DisplayCaptureSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "monitor_capture");
  }

}

class VideoCaptureSource extends Source {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "av_capture_input");
  }

}

class CropPadFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "crop_filter");
  }

}

class LumaKeyFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "luma_key_filter_v2");
  }

}

class ApplyLUTFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "clut_filter");
  }

}

class ColorCorrectionFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "color_filter_v2");
  }

}

exports.ChromaKeyColorType = void 0;

(function (ChromaKeyColorType) {
  ChromaKeyColorType["Green"] = "green";
  ChromaKeyColorType["Blue"] = "blue";
  ChromaKeyColorType["Magenta"] = "magenta";
  ChromaKeyColorType["Custom"] = "custom";
})(exports.ChromaKeyColorType || (exports.ChromaKeyColorType = {}));

class ChromaKeyFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "chroma_key_filter_v2");
  }

}

exports.ColorKeyColorType = void 0;

(function (ColorKeyColorType) {
  ColorKeyColorType["Green"] = "green";
  ColorKeyColorType["Blue"] = "blue";
  ColorKeyColorType["Red"] = "red";
  ColorKeyColorType["Magenta"] = "magenta";
  ColorKeyColorType["Custom"] = "custom";
})(exports.ColorKeyColorType || (exports.ColorKeyColorType = {}));

class ColorKeyFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "color_key_filter_v2");
  }

}

class AspectRatioFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "scale_filter");
  }

}

class ApplyLutFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "clut_filter");
  }

}

exports.MaskBlendSelect = void 0;

(function (MaskBlendSelect) {
  MaskBlendSelect["AlphaMaskAlphaChannel"] = "mask_alpha_filter.effect";
  MaskBlendSelect["AlphaMaskColourChannel"] = "mask_colour_filter.effect";
  MaskBlendSelect["BlendMultiply"] = "blend_mul_filter.effect";
  MaskBlendSelect["BlendAddition"] = "blend_add_filter.effect";
  MaskBlendSelect["BlendSubtraction"] = "blend_sub_filter.effect";
})(exports.MaskBlendSelect || (exports.MaskBlendSelect = {}));

class ImageMaskBlendFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "mask_filter_v2");
  }

}

class RenderDelayFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "gpu_delay");
  }

}

class ScrollFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "scroll_filter");
  }

}

class SharpenFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "sharpness_filter_v2");
  }

}

class CompressorFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "compressor_filter");
  }

}

exports.ExpanderDetectorType = void 0;

(function (ExpanderDetectorType) {
  ExpanderDetectorType["RMS"] = "RMS";
  ExpanderDetectorType["Peak"] = "peak";
})(exports.ExpanderDetectorType || (exports.ExpanderDetectorType = {}));

exports.ExpanderPreset = void 0;

(function (ExpanderPreset) {
  ExpanderPreset["Expander"] = "expander";
  ExpanderPreset["Gate"] = "gate";
})(exports.ExpanderPreset || (exports.ExpanderPreset = {}));

class ExpanderFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "expander_filter");
  }

}

class GainFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "gain_filter");
  }

}

class InvertPolarityFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "gain_filter");
  }

}

class LimiterFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "limiter_filter");
  }

}

class NoiseGateFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "noise_gate_filter");
  }

}

exports.NoiseSuppressMethod = void 0;

(function (NoiseSuppressMethod) {
  NoiseSuppressMethod["Speex"] = "speex";
  NoiseSuppressMethod["RNNoise"] = "rnnoise";
  NoiseSuppressMethod["NVAFX"] = "nvafx";
})(exports.NoiseSuppressMethod || (exports.NoiseSuppressMethod = {}));

class NoiseSuppressFilter extends Filter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "type", "noise_suppress_filter");
  }

}

exports.ApplyLUTFilter = ApplyLUTFilter;
exports.ApplyLutFilter = ApplyLutFilter;
exports.AspectRatioFilter = AspectRatioFilter;
exports.BrowserSource = BrowserSource;
exports.BrowserSourceItem = BrowserSourceItem;
exports.ChromaKeyFilter = ChromaKeyFilter;
exports.ColorCorrectionFilter = ColorCorrectionFilter;
exports.ColorKeyFilter = ColorKeyFilter;
exports.ColorSource = ColorSource;
exports.CompressorFilter = CompressorFilter;
exports.CropPadFilter = CropPadFilter;
exports.DEFAULT_SCENE_ITEM_PROPERTIES = DEFAULT_SCENE_ITEM_PROPERTIES;
exports.DisplayCaptureSource = DisplayCaptureSource;
exports.ExpanderFilter = ExpanderFilter;
exports.Filter = Filter;
exports.FreetypeTextSource = FreetypeTextSource;
exports.GDIPlusTextSource = GDIPlusTextSource;
exports.GainFilter = GainFilter;
exports.ImageMaskBlendFilter = ImageMaskBlendFilter;
exports.ImageSource = ImageSource;
exports.InvertPolarityFilter = InvertPolarityFilter;
exports.LimiterFilter = LimiterFilter;
exports.LumaKeyFilter = LumaKeyFilter;
exports.MediaSource = MediaSource;
exports.NoiseGateFilter = NoiseGateFilter;
exports.NoiseSuppressFilter = NoiseSuppressFilter;
exports.RenderDelayFilter = RenderDelayFilter;
exports.Scene = Scene;
exports.SceneItem = SceneItem;
exports.ScrollFilter = ScrollFilter;
exports.SharpenFilter = SharpenFilter;
exports.Source = Source;
exports.VideoCaptureSource = VideoCaptureSource;
exports.obs = obs;
//# sourceMappingURL=index.js.map
