import ObsWebSocket from "obs-websocket-js";
import type { Scene } from "../Scene";
import { RequestArgsMap, RequestResponseMap, EventsDataMap } from "./socket";
import { Source } from "../Source";
import { DeepPartial } from "../types";
import { SceneItemProperties } from "../SceneItem";
interface ConnectArgs {
    address?: string;
    password?: string;
    secure?: boolean;
}
declare class OBS {
    socket: ObsWebSocket;
    LOGGING: boolean;
    sources: Map<string, Source<import("../Source").SourceSettings, import("../Source").SourceFilters>>;
    scenes: Map<string, Scene<{}, {}, import("../Source").SourceFilters>>;
    /**
     * Set this to true at your own peril. While batching should work, it is untested and
     * sometimes results in requests never being returned as complete.
     */
    useBatching: boolean;
    connect(args: ConnectArgs): Promise<void>;
    clear(): void;
    disconnect(): void;
    /**
     * Goes though each source in OBS and removes it if 1. simple-obs owns it and 2. there are no references
     * to the source in code.
     */
    clean(): Promise<void>;
    batchedSends: {
        "request-type": string;
        "message-id": string;
        [key: string]: any;
    }[];
    sendBatch(): Promise<void>;
    queued: boolean;
    queueSendBatch(): void;
    batchSend(data: object): void;
    send<T extends keyof RequestArgsMap>(type: T, ...[args]: RequestArgsMap[T] extends object ? [RequestArgsMap[T]] : [undefined?]): Promise<RequestResponseMap[T]>;
    on<T extends keyof EventsDataMap>(type: T, listener: (data: EventsDataMap[T]) => void): ObsWebSocket;
    off<T extends keyof EventsDataMap>(type: T, listener: (data: EventsDataMap[T]) => void): ObsWebSocket;
    setSourceSettings(args: {
        name: string;
        type: string;
        settings: object;
    }): Promise<{
        sourceName: string;
        sourceType: string;
        sourceSettings: object;
    }>;
    createSource(args: {
        name: string;
        type: string;
        scene?: string;
        settings: Record<string, any> & {
            visible?: boolean;
        };
    }): Promise<{
        itemId: number;
    }>;
    createScene(name: string): Promise<{}>;
    removeScene(name: string): Promise<void>;
    getSceneItemList(sceneName: string): Promise<{
        sceneName: string;
        sceneItems: {
            itemId: number;
            sourceKind: string;
            sourceName: string;
            sourceType: "scene" | "input" | "group";
        }[];
    }>;
    addSceneItem(args: {
        scene: string;
        source: string;
        visible?: boolean;
    }): Promise<{
        itemId: number;
    }>;
    setSceneItemProperties({ scene, name, id, position, bounds, crop, scale, ...properties }: {
        scene: string;
        name?: string;
        id?: number;
    } & DeepPartial<SceneItemProperties>): Promise<{}>;
    setCurrentScene(scene: string): Promise<{}>;
    getSceneItemProperties({ id, name, scene, }: {
        scene: string;
        name?: string;
        id?: number;
    }): Promise<SceneItemProperties & {
        itemId: number;
        name: string;
    }>;
    getSourceSettings(args: {
        name: string;
        type?: string;
    }): Promise<{
        sourceName: string;
        sourceType: string;
        sourceSettings: Record<string, any>;
    }>;
    getSceneList(): Promise<{
        "current-scene": string;
        scenes: {
            name: string;
            sources: {
                type: string;
                name: string;
                id: number;
            }[];
        }[];
    }>;
    deleteSceneItem({ scene, name, id, }: {
        scene: string;
        name?: string;
        id?: number;
    }): Promise<{}>;
    addFilterToSource({ source, name, type, settings, }: {
        source: string;
        name: string;
        type: string;
        settings: any;
    }): Promise<{}>;
    setSourceFilterSettings({ source, filter, settings, }: {
        source: string;
        filter: string;
        settings: object;
    }): Promise<{}>;
    setSourceFilterVisibility({ source, filter, visible, }: {
        source: string;
        filter: string;
        visible: boolean;
    }): Promise<{}>;
    removeFilterFromSource({ source, filter, }: {
        source: string;
        filter: string;
    }): Promise<{}>;
    getSourceFilters({ source }: {
        source: string;
    }): Promise<{
        filters: {
            enabled: boolean;
            type: string;
            name: string;
            settings: {};
        }[];
    }>;
    reorderSourceFilter({ source, filter, newIndex, }: {
        source: string;
        filter: string;
        newIndex: number;
    }): Promise<{}>;
    getSourceFilterInfo({ source, filter }: {
        source: string;
        filter: string;
    }): Promise<{
        enabled: boolean;
        type: string;
        name: string;
        settings: {};
    }>;
    reorderSceneItems({ scene, items }: {
        scene: string;
        items: number[];
    }): Promise<{}>;
    getSourcesList(): Promise<{
        sources: {
            name: string;
            typeId: string;
            type: string;
        }[];
    }>;
    getSourceTypesList(): Promise<{
        types: {
            typeId: string;
            displayName: string;
            defaultSettings: object;
            caps: {
                isAsync: boolean;
                hasVideo: boolean;
                hasAudio: boolean;
                canInteract: boolean;
                isComposite: boolean;
                doNotDuplicate: boolean;
                doNotSelfMonitor: boolean;
            };
        }[];
    }>;
    getVideoInfo(): Promise<{
        baseWidth: number;
        baseHeight: number;
        outputWidth: number;
        outputHeight: number;
        scaleType: string;
        fps: number;
        videoFormat: string;
        colorSpace: string;
        colorRange: string;
    }>;
    log(...messages: any[]): void;
}
export declare const obs: OBS;
export {};
//# sourceMappingURL=index.d.ts.map