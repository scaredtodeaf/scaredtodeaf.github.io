import { Scene } from "./Scene";
import { Filter } from "./Filter";
import { SceneItem, SceneItemProperties } from "./SceneItem";
import { DeepPartial } from "./types";
export declare type SceneName = string;
export declare type ItemRef = string;
export declare type ItemID = number;
export declare type SourceRefs = Record<SceneName, Record<ItemRef, ItemID>>;
export declare type SourceFilters = Record<string, Filter>;
export declare type SourceSettings = Record<string, any>;
export declare abstract class Source<Settings extends SourceSettings = SourceSettings, Filters extends SourceFilters = SourceFilters> {
    abstract type: string;
    _settingsType: Settings;
    name: string;
    settings: DeepPartial<Settings>;
    filters: Filters & Record<string, Filter>;
    linked: boolean;
    itemInstances: Set<SceneItem<Source<SourceSettings, SourceFilters>, SceneItemProperties>>;
    /**
     * Whether this source has at least one scene item in OBS
     */
    get exists(): boolean;
    protected _exists: boolean;
    /**
     * Whether `initialize` has been called on this source yet
     */
    get initalized(): boolean;
    protected _initialized: boolean;
    constructor(args: {
        name: string;
        settings?: DeepPartial<Settings>;
        filters?: Filters;
    });
    /**
     * Sets this source's settings, both on this instance and the OBS source.
     *
     */
    setSettings(settings: DeepPartial<Settings>): Promise<void>;
    /**
     * Adds a filter to this source, provided that 1. The filter has not already been applied
     * to another source, and 2. The source in OBS does not have a filter with a different type
     * but the same name as the filter being added. Does not support inserting at a particular order as of yet.
     */
    addFilter(ref: string, filter: Filter): Promise<void>;
    /**
     * Overridable function for creating `SceneItem` instances for a source.
     * Doesn't create any objects in OBS. Instead, creates `SceneItem` instances that can
     * override default `SceneItem` behaviours.
     *
     * @returns An instance of `SceneItem` or a class that derives it.
     */
    createItemInstance(scene: Scene, id: number, ref: string): SceneItem<this>;
    /**
     * Updates the source's filters in OBS so that they match the filters defined in `this.filters`.
     * This is done by removing filters that are present on the source in OBS but not on `this`, and adding filters that are present on `this` but not on the source.
     *
     * This shouldn't be required very often, probably only on source initialization.
     */
    refreshFilters(): Promise<void>;
    /**
     * Fetches initial data for the source.
     *
     * @returns If the source has been initialized (will always be `true`).
     * Returns true immediately if already initialized, else will return a promise that resolves
     * when initialization is finished.
     *
     * Avoiding returning a promise where possible allows for tighter batching of obs requests that
     * happen in the same tick.
     *
     * @internal
     *
     */
    initialize(): true | Promise<true>;
    /**
     * Creates a scene item of this source in the provided scene.
     * Requires that this source has been initialized.
     * If the source already exists, a new scene item will be created.
     * If not, the source will be created and added to the scene.
     *
     * @returns A SceneItem created by `Source.createSceneItem`
     * @internal
     */
    createItem(ref: ItemRef, scene: Scene): Promise<SceneItem<this>>;
    /**
     * Uses the source's filterSchema to populate the filters property,
     * creating/linking with filters in OBS in the process.
     */
    private initializeFilters;
    /**
     * Creates an instance of the source with the provided data and marks itself as existing and
     * initialized, as if the source was created by code.
     *
     * TODO: Matching settings and filters?
     *
     * @internal
     */
    linkItem(scene: Scene, id: ItemID, ref: string): SceneItem<this, SceneItemProperties>;
    /**
     * REFS MANAGEMENT
     *
     * Methods and state for managing refs: Data stored in OBS that
     * links scene item references in code to scene item IDs in OBS,
     * so that scene items created in code can be recovered after code restarts,
     * removing the need for all scene items to be removed and recreated to guarantee
     * consistency between code and OBS.
     */
    /**
     * Source's refs.
     * Populated from OBS once on source creation but controlled by the source from then on.
     */
    private refs;
    /**
     * Sends this source's refs to OBS to be saved onto the source
     *
     * @throws If saving the refs fails
     */
    protected saveRefs(): Promise<{
        sourceName: string;
        sourceType: string;
        sourceSettings: object;
    }>;
    protected getRef(scene: SceneName, ref: ItemRef): ItemID | undefined;
    protected addRef(scene: SceneName, ref: ItemRef, id: ItemID): void;
    protected removeRef(scene: SceneName, ref: ItemRef): void;
    /**
     * Gathers this source's itemRefs, calculates the refs value accordingly, and forcefully
     * pushes it to the source in OBS. This method is destructive, and should only be used sparingly.
     *
     * @internal
     */
    pushRefs(): Promise<{
        sourceName: string;
        sourceType: string;
        sourceSettings: object;
    }>;
}
//# sourceMappingURL=Source.d.ts.map